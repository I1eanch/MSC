name: Deploy Backend to AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: 'staging'

permissions:
  id-token: write
  contents: read

jobs:
  deploy-backend:
    name: Deploy Backend to AWS
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "dir=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ steps.pnpm-cache.outputs.dir }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build backend
        run: pnpm --filter backend build
        env:
          NODE_ENV: production

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_BACKEND || 'backend' }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cat > Dockerfile <<EOF
          FROM node:18-alpine AS builder
          
          WORKDIR /app
          
          # Install pnpm
          RUN npm install -g pnpm@8
          
          # Copy workspace files
          COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
          COPY turbo.json ./
          COPY tsconfig.json ./
          
          # Copy backend and shared packages
          COPY apps/backend ./apps/backend
          COPY packages ./packages
          
          # Install dependencies
          RUN pnpm install --frozen-lockfile
          
          # Build backend and dependencies
          RUN pnpm --filter backend build
          
          # Production stage
          FROM node:18-alpine
          
          WORKDIR /app
          
          # Install pnpm
          RUN npm install -g pnpm@8
          
          # Copy package files for production install
          COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
          COPY apps/backend/package.json ./apps/backend/
          COPY packages ./packages
          
          # Install production dependencies only
          RUN pnpm install --frozen-lockfile --prod
          
          # Copy built application
          COPY --from=builder /app/apps/backend/dist ./apps/backend/dist
          
          WORKDIR /app/apps/backend
          
          EXPOSE 3000
          
          CMD ["node", "dist/main.js"]
          EOF
          
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                       -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                       -f Dockerfile .

      - name: Push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_BACKEND || 'backend' }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Deploy to ECS
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_BACKEND || 'backend' }}
          IMAGE_TAG: ${{ github.sha }}
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE_BACKEND }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION_BACKEND }}
        run: |
          # Download current task definition
          aws ecs describe-task-definition \
            --task-definition $ECS_TASK_DEFINITION \
            --query taskDefinition > task-definition.json
          
          # Update image in task definition
          cat task-definition.json | \
          jq --arg IMAGE "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" \
             '.containerDefinitions[0].image = $IMAGE | 
              del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
             > new-task-definition.json
          
          # Register new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "New task definition: $NEW_TASK_DEF"
          
          # Update ECS service
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $NEW_TASK_DEF \
            --force-new-deployment
          
          echo "âœ… Backend deployment initiated"

      - name: Wait for deployment to stabilize
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE_BACKEND }}
        run: |
          echo "â³ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE
          echo "âœ… Deployment completed successfully"

      - name: Run database migrations
        if: github.event.inputs.environment == 'staging'
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION_BACKEND }}
          SUBNET_ID: ${{ secrets.SUBNET_ID }}
          SECURITY_GROUP_ID: ${{ secrets.SECURITY_GROUP_ID }}
        run: |
          echo "Running database migrations..."
          
          aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $ECS_TASK_DEFINITION \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=ENABLED}" \
            --overrides '{
              "containerOverrides": [{
                "name": "backend",
                "command": ["sh", "-c", "pnpm --filter backend db:migrate"]
              }]
            }'
          
          echo "âœ… Database migrations completed"

      - name: Verify deployment
        env:
          API_URL: ${{ secrets.API_URL }}
        run: |
          echo "Verifying deployment..."
          sleep 10
          
          response=$(curl -s -o /dev/null -w "%{http_code}" $API_URL/api/health || echo "000")
          
          if [ "$response" == "200" ]; then
            echo "âœ… Health check passed"
          else
            echo "âŒ Health check failed with status: $response"
            exit 1
          fi

      - name: Create deployment summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš€ Backend Deployment Summary
          
          ## Details
          - **Environment**: ${{ github.event.inputs.environment }}
          - **Commit**: ${{ github.sha }}
          - **Image Tag**: ${{ github.sha }}
          - **Status**: ${{ job.status }}
          
          ## Deployed Services
          - Backend API
          - Database Migrations
          
          ## Health Check
          - Endpoint: ${{ secrets.API_URL }}/api/health
          EOF

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸš€ **Backend Deployed to ${{ github.event.inputs.environment }}**
              
              - **Commit**: ${{ github.sha }}
              - **Image Tag**: ${{ github.sha }}
              - **API URL**: ${{ secrets.API_URL }}
              
              Health check: ${{ secrets.API_URL }}/api/health`
            })

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy-backend
    if: always()
    steps:
      - name: Send notification
        run: |
          if [ "${{ needs.deploy-backend.result }}" == "success" ]; then
            echo "âœ… Backend deployed successfully to ${{ github.event.inputs.environment }}"
          else
            echo "âŒ Backend deployment failed"
            exit 1
          fi
